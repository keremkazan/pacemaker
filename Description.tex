\documentclass[a4paper]{article}

\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage{multirow}
\usepackage[margin=1in]{geometry}
\usepackage{multicol}

\title{Pacemaker UPPAAL Abstraction}

\author{Sindhu Honnali, Hitali Sheth, Kerem Kazan, David Freifelder}

\begin{document}
\maketitle

\section{Modeling}
The following automata have been designed to model the pacemaker for this milestone.
\subsection{Keyboard}
\begin{multicols}{2}
Simulates key presses by generating a random value from 1 to 13 at arbitrary intervals. This value is then received by mode switch automata which select the modes for heart and the pacemaker.
The following are the key press values and their corresponding actions.

\begin{tabular}{| l | r |}
  \hline
  \multicolumn{2}{|c|}{Pacemaker Controls} \\
  \hline
  1 & Normal Mode \\
  2 & Sleep Mode \\
  3 & Exercize Mode \\
  4 & Manual Mode \\
  5 & Generate {\tt APace} \\
  6 & Generate {\tt VPace} \\
  7 & Modify Observation Interval \\
  \hline
  \multicolumn{2}{|c|}{Heart Controls} \\
  \hline
  8 & Random Mode \\
  9 & Manual Mode  \\
  10 & Test Mode  \\
  11 & Generate {\tt ASense} \\
  12 & Generate {\tt VSense} \\
  13 & Modify Observation Interval \\
  \hline
\end{tabular}
\end{multicols}

\subsection{Mode Switch} This template dictates the modes of pacemaker and heart based on the key pressed values. To change from one mode to another for heart and pacemaker we test the corresponding guard conditions.  These guard conditions check both that the correct key was simulated, and that changing this mode does not create inconsistent state (as modifying certain variables at the wrong time may violate invariants.)

\subsection{Heart} This automata consists of two parts. 
\begin{enumerate}
\item The first part models random mode, manual mode and receives signals from the pacemaker. In the manual mode, when the appropriate key value is received, {\tt ASense} and {\tt VSense} signals are generated and clocks are reset. In the random model, {\tt ASense} and {\tt VSense} signals are generated randomly. The heart also receives the signals generated by pacemaker when there is a failure in generating signals by the heart or if pacemaker is in manual mode and resets the clock. This way both heart and pacemaker are synchronized.
\item The second portion is a test mode.  In this mode, the heart non-deterministically chooses a test from its entry point and executes it, raising a flag variable if it fails.
\begin{itemize}
\item Normal operation test : In this test the heart functions normally; i.e. the heart generates {\tt ASense} and {\tt VSense} at the correct rate and hence signals are not required to be generated by the pacemaker.  If any of the signals are generated by the pacemaker, the test fails.
\item {\tt VSense} exceeds : In this test, if {\tt VSense} is not received after VRP and before LRI , then {\tt VPace} gets generated by the pacemaker at the LRI. If {\tt VSense} is received within VRP, then {\tt VSense} is ignored by the heart and by the pacemaker and heart expects the next signal as {\tt APace} at LRI - AVI. 
\item {\tt ASense} exceeds :  In this test, if {\tt ASense} is not received at LRI - AVI, then {\tt APace} is expected. If {\tt ASense} is received after LRI - AVI, then it is ignored and the heart expects the next signal as {\tt VPace} at LRI.
\item {\tt ASense} too soon : In this test, if the {\tt ASense} is received within PVARP, then it gets ignored and the heart expects {\tt APace} at LRI - AVI. 
\item {\tt VSense} too soon: In this test, if {\tt VSense} is asserted before URI or before AVI-min or before VRP, {\tt VSense} needs to be ignored and the heart expects {\tt VPace} at LRI.
\end{itemize}
Each of the above tests checks the pacemaker's response to the various ways it is expected to react: it does not disrupt correct behavior, triggers if atrial or ventricle signals miss their interval, and ignores signals that occur within a period of uncertainty.
\end{enumerate}
\subsection{Pacemaker} The pacemaker model has two main locations: {\tt ANext} and {\tt VNext}. There exist two clocks in the system: one representing time since the last acknowledged atrial event (cA) and the other for the last ventricle event (cV). During the normal, exercise and sleep modes of the pacemaker, when the pacemaker is in {\tt ANext} state, it waits for a properly timed {\tt ASense} signal, and if the signal is not received the pacemaker generates {\tt APace} and moves to the {\tt VNext} state. In the {\tt VNext} state, the pacemaker waits for a properly timed {\tt VSense} signal, and if the signal is not received the pacemaker generates {\tt VPace} and moves to the {\tt ANext} state.

When the pacemaker is in the manual mode, which may be reached from either state, the keys for atrial and ventricle signals generate the corresponding {\tt APace} and {\tt VPace} signals, and the clocks are reset as appropriate.  Note that being in manual mode may violate the invariants of the other modes, so changing back to automatic is restricted by those same invariants.

\subsection{LED} The four LEDs blink when the corresponding {\tt APace}, {\tt ASense}, {\tt VPace} and {\tt VSense} signals are generated.

\subsection{Display} A pair of these templates are initialized, corresponding to the heart and pacemaker controls.  When {\tt VSense} or {\tt VPace} signal is received within the observation interval of the appropriate target, the counter is incremented to keep count of the heart beat, and later the heart rate is displayed. 

The representation here is somewhat restricted by state-space concerns; since the number of heart-beats can become arbitrarily great due to the random heart or user input, the state-space required for verification becomes too great.  Thus, the counter is instead modeled with a channel to increment and a channel to display and reset.  In an implementation of this section, these channels would be replaced by the appropriate methods.\footnote{In practice, the verification is further restricted by general complexity.  Adding a pair of clocks for the purpose of display causes exponential run-time increases in simulation; for this reason we provide the replacement template DisplayFast, which provides the same abstraction at a fraction of the simulation rate.  The difference between these two templates is purely internal; using one or the other should not change the results of the verification queries.}

\subsection{Alarm} If the {\tt VPace} or {\tt VSense} is received at time less than URI, {\tt alarmFast} is set.  Similarly, if  the {\tt VPace} or {\tt VSense} is received at time  greater than LRI, {\tt {\tt alarmSlow}} is set.  These boolean variables correspond to the appropriate alarm sounds that would be triggered in an actual implementation.

\section{Verification}
The following queries are presented to verify the various safety and liveness properties of the system.
\begin{enumerate}
\item {\tt A[] not deadlock} : Checks for any deadlock in the system.

\item {\tt A[] not fail} :  In the heart's test mode, {\tt fail} is asserted when an unwanted {\tt VPace} or {\tt APace} is detected, or is not detected but should have been.  This query verification asserts that all the tests pass, since any may be entered non-deterministically, and also shows that within the bounds of any particular pacemaker mode, the pacemaker performs as it should, satisfying the conditions below:
\begin{itemize}
\item If the heart acts as normal, no pacemaker activity is generated
\item {\tt ASense} may not be acknowledged within PVARP
\item {\tt VSense} may not be acknowledged within VRP
\item If {\tt ASense} is not received before LRI - AVI, then {\tt APace} is generated
\item If {\tt VSense} is not received before LRI, then {\tt VPace} is generated by the pacemaker
\end{itemize}

\item {\tt A.VReceived \&\& cV > LRI[paceMode] --> alarmSlow} : {\tt alarmSlow} is set when  a ventricular signal is received after the expected interval between ventricular signals, LRI, is surpassed.

\item {\tt A.VReceived \&\& cV < URI[paceMode] --> alarmFast} : {\tt alarmFast} is set when the expected  minimum interval between ventricular signals, URI, is not yet over and still a ventricular signal is received.

\item {\tt A[] (L.BlinkAP imply cA == 0)} \\
      {\tt A[] (L.BlinkVP imply cV == 0)} \\
      {\tt A[] (L.BlinkAS imply ASC.c == 0)} \\
      {\tt A[] (L.BlinkVS imply VSC.c == 0)} : cA and cV are clocks which are set when atrial or ventricular signals take place. The first two queries check that if the atrial or ventricular signals are generated by the pacemaker, then the corresponding  LED blinks.  The second two queries do the same for the signals from the heart, making use of a helper template to keep track of the signal.

\item {\tt A[] P.APSend imply (cV == LRI[paceMode] - AVI-min) and (cV >= PVARP)}

This test verifies the conditions required for the pacemaker to send the {\tt APace} signal.  The time since the last ventricle event must be greater than PVARP, and the pacemaker should not intervene if the clock has not exceeded the amount of time within which the heart should have triggered a sense event.  The latter is shown by the upper bound between cycles (LRI of the current pace mode), minus the time needed before the next ventricle event, AVI-min.

\item {\tt A[] P.VPSend imply (cALast == AVI-max and cALast > AVI-min) or (cVLast == LRI[paceMode] and cVLast > URI[paceMode] and cVLast > VRP)}

This test verifies the conditions required for the pacemaker to send the {\tt VPace} signal.  There are two reasons this may occur; either the time since the last atrial event is too great, or the time since the last ventricle event.  If the former is true, the time must be at the upper bound between atrial and ventricle events (AVI-max) and exceed the minimum.  If the former is true, the time between ventricle events must be at its maximum (LRI of the current pace mode), and must exceed both the lower bound of that range and VRP.

\end{enumerate}

As we have asserted that the pacemaker sends signals when required, and that it only sends signals when required, we have verified that the pacemaker sends signals {\it if and only if the specifications say that it should}.  That these queries can be successfully verified shows both the correctness and the liveness properties of the system.


\end{document}